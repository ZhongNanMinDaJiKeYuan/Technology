
###  事务
事务：事务提供了一种将多个命令打包，然后一次性、按顺序执行的机制，事务在执行的期间不会中断，服务器在执行完事务中所有的命令以后才会继续处理其他客户端的其他命令。

#### 1 事务的流程
Redis使用MULTI命令开始一个事务，然后将多个命令入队到事务队列中，最后通过EXEC命令触发事务，一并执行事务中的所有命令。所以一个事务执行过程有三个阶段：开始事务、命令入队、执行事务。
* 开始事务：MULTI命令执行的结果是将客户端的REDIS_MULTI选项打开，从而使客户端从非事务状态转到事务状态。
* 命令入队：在事务状态下，Redis系统将多条命令放到事务队列中，事务队列是一个数组用来存放命令的相关信息，命令的操作结果返回QUEUE。(在非事务状态下，Redis系统直接执行命令返回对应的结果)
* 执行事务：如果客户端正处于事务状态，当EXEC命令执行时，服务器按照先进先出的方式执行事务队列中的命令。执行事务中的命令结果会以先进先出的方式进入到回复队列中。当事务队列中的所有命令执行完毕，EXEC命令会将回复队列中的结果返回给客户端并将客户端的状态改为非事务状态，至此一个事务结束。
#### 2 事务状态和非事务状态的异同
相同点：无论是事务状态还是非事务状态下，命令的执行函数是相同的，命令共享服务器中的一般设置：AOF设置，RDB设置，内存限制等等。

不同点：
* 1.非事务状态下，命令以单条命令为单位去执行并返回结果，前一条命令和后一条命令的客户端不一定相同。事务状态下，命令以事务为单位去执行并返回结果，前一条命令和后一条命令在同一个事务队列中来自于同一个客户端。

* 2.非事务状态下，命令会立刻执行并返回给客户端。事务状态下，命令执行以后被放进回复队列中，事务队列中所有的命令都执行完毕以后才会将回复队列中的结果返回给客户端。

#### 3 事务状态下的DISCARD、MULTI和WATCH命令
除了EXEC命令之外，服务器在客户端处于事务状态时，不加入到事务队列而直接执行的命令是：DISCARD、MULTI和WATCH。

DISCARD命令用于取消事务，它清空客户端的整个队列，然后将客户端的事务状态调整为非事务状态，并返回OK给客户端，说明事务已经被取消。

Redis的事务是不可嵌套的，当客户端已经处于事务状态，而客户端又再向服务器发送MULTI时，服务器只是给客户端返回一个错误，MULTI命令不会造成事务失败，也不会改变事务队列中的数据。

WATCH命令只能在客户端进入事务队列之前执行，在事务状态下发送WATCH命令，服务器会返回一个错误，但它不会造成事务失败，也不会改变事务队列中的数据。
#### 4 带WATCH的事务
WATCH命令用于在事务开始之前监视任意数量的键，当事务执行EXEC命令的时候，如果监视的键已经被其他的客户端修改，那么整个事务不再执行，直接返回失败。

WATCH命令的实现：在每个代表数据库的结构中，都有一个watched_keys字典，字典的键就是这个数据库被监视的键，而字典的值是一个链表，用来存储所有监视这个键的客户端。WATCH命令的作用就是将当前客户端和需要监视的键进行关联(链在链表的尾部）。通过watched_keys字典能够快速的判断某一个键是否被监视，通过遍历链表可以快速获取监视一个键的所有客户端。

WATCH命令的触发：当任何对数据库键空间进行修改的命令被成功执行以后，Redis系统会查看数据库结构中的watched_keys字典，检查被监视的键是否发生了修改，如果发生了修改表示客户端的事务安全性被破坏，放弃执行当前事务，服务器给客户端返回一个错误。

#### 5 事务的ACID属性
传统的关系型数据库通过ACID性质来检验事务的安全性，但是Redis系统只能保证事务的一致性(C）和隔离性(I)，并不能保证原子性(A)和持久性(D)。

原子性（Atomicity）：单个Redis命令是原子性的，但是Redis事务并不支持原子性，当Redis事务在执行过程中被其他的客户端停止(例如接收到了KILL信号、服务器停机等）时，事务会执行失败。Redis事务执行失败的时候，不会进行任何重试和回滚操作。

一致性( Consistency ):入队错误、执行错误、Redis进程被终结。
* 入队错误：在命令入队的过程中，如果客户端向服务器发送了一个错误命令，此时服务器会向客户端返回一个出错信息，并且改变客户端的事务状态为REDIS_DIRTY_EXEC。当客户端执行EXEC命令时，Redis服务器会拒绝执行事务状态为REDIS_DIRTY_EXEC的事务，服务器向客户端返回错误信息。所以带有错误数据命令不会进入事务队列，不会影响事务的正常执行，从而不会影响数据库的一致性。
* 执行错误：当事务在执行过程中发生了错误，服务器会将一个错误推送到回复队列中，这个错误不影响事务中前面命令的执行结果，也不影响事务中后面命令的执行，所以不会影响整个事务的正常执行，从而不会影响数据库的一致性。
* Redis进程被终结：如果Redis服务器进程在执行事务的过程中被其他进程终结，或者被管理员权限强制杀死，那么根据Redis所使用的持久化模式，可能有一下的情况出现：

1. 内存模式：如果Redis没有采取任何持久化机制，那么在重启Redis服务器的时候，数据库总是空白的，所以数据是一致的。

  2. RDB模式：在执行事务的时候，Redis不会中断事务去执行保存RDB的操作，只有当事务执行完毕以后，保存RDB的工作才会开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。
  
  3. AOF模式：保存AOF文件的工作在后台线程中进行，所以即使是Redis事务在执行的中途，保存AOF文件的工作也可以继续进行，所以根据事务是否被保存到AOF中文件，有两种情况会发生：
  
     （1）如果事务没有被写入AOF文件中，或者AOF文件并没有被加载到磁盘，那么当进程被杀死的时候， Redis根据最近一次成功保存到磁盘的AOF文件来还原数据库，如此数据库中的数据能够保持一致性，但其中的数据不一定是最新的数据。
     
     （2）如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。

隔离性（isolation）：Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。

持久性（Durability）：因为事务用队列重载的一组Redis命令，本身没有提供任何额外的持久性功能，所以事务的持久性是由Redis所用的持久化模式来决定的：
* 单纯的内存模式下，Redis不具有持久性。

* 在RDB模式下，服务器可能在事务执行之后，RDB文件更新之前的这段时间失败，所以Redis在RDB模式下不具有持久性。

* 在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync或fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。

  综上所述：Redis事务不具有持久性。
