## 内存映射数据结构<br>
### 1 整数集合<br>
**1.1 整数集合(Intset)** <br>
&emsp;&emsp;整数集合用于有序、无重复地保存多个整数值，能够根据元素的值（改变编码类型）自动选择该用什么长度的整形类型来保存。例如，一个Intset中最长的元素可以用16位来保存，那么这个intset中所有的元素都可以用16位来保存，当需要插入一个32位的整数时，Intset自动扩容到单个存储单元能够存储32位的整数。  

**1.2 Intset**<br>
&emsp;&emsp;Intset是集合键的底层实现之一，如果一个集合只能存储整形数据，且数据数量不多，Redis就会用Intset去保存集合元素。  

**1.3 向Intset中添加元素**<br>
创建Intset完毕以后，添加一个元素到Intset会有三种情况：<br>
*  Intset中本身就有这个元素，不做任何操作。<br>
*  Intset中没有这个元素，并且添加元素不需要对Intset进行升级。  <br>
*  Intset中没有这个元素，但是添加元素需要对Intset进行升级。  

**1.4 关于升级的说明**<br>
*  从短整型到长整型的转换不会改变元素的值（只改变类型位长度）。<br>
*  升级的编码格式由Intset中长度最大的那个值来决定。  

**1.5 Intset的有序性**<br>
&emsp;&emsp;Intset是有序的，contents属性保证了Intset的有序性，所以Intset可以通过二分查找法来实现查找操作。<br>
###   2 压缩列表  
**2.1 压缩列表**  
&emsp;&emsp;压缩列表（Ziplist）是由一系列特殊编码的内存块构成的列表（由连续的内存块构成），每一个压缩列表可以包含多个节点，每个节点可以存储一个长度受限的字符数组，或者整数。因为压缩列表节约内存，所以是哈希键、列表键和有序集合键的底层实现之一。  

**2.2 压缩列表的域**<br>
* zlbytes：表示整个压缩列表占用内存的字节数，用于对压缩列表进行重新分配或者计算末端地址。<br>
* zlbytes：zltail:到达压缩列表尾节点的偏移量，能够在不遍历整个压缩列表的情况下弹出尾结点。<br>
* zllen：节点的数量。<br>
**注意：zlbytes、zltail、zllen共同组成了压缩列表的header部分。**<br>
* entryX：压缩列表中保存的节点，长度视内容决定。<br>
* zlend：一个二进制的标识位，用于标识压缩列表的末端。  

**2.3 节点的构成**<br>
&emsp;&emsp;压缩列表的节点有四个组成部分：pre_entry_length、encoding、length、content。<br>
* pre_entry_length：表示前一个节点的长度。<br>
* encoding：表示数据的类型。<br>
* length:表示节点的长度。<br>
* content:表示节点的内容。  

**2.4 创建新的压缩列表**<br>
&emsp;&emsp;创建新的压缩列表首先需要建立一个表，然后往空表中插入节点，插入节点有两种方式：<br>
* 将节点添加到压缩列表的末端，此时新节点后面没有任何节点。<br>
* 将节点添加到某个/某些节点的前面，此时新节点后面至少有一个节点。<br>
*除此之外还有删除节点、遍历压缩列表、查找元素等操作，大家可以参考数组类比理解。*
